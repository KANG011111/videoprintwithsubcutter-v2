<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端字幕截圖工具 - 包含模式3</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>前端字幕截圖工具</h1>

    <div class="main-container">
        <div class="left-panel">
            <div class="section" id="video-section">
                <h2>1. 影片區</h2>
                <div class="input-group">
                    <label for="video-file-input">上傳影片檔 (MP4/WebM)</label>
                    <input type="file" id="video-file-input" accept="video/mp4,video/webm">
                </div>
                <video id="video-player" controls crossorigin="anonymous"></video>
            </div>

            <div class="section" id="subtitle-section">
                <h2>2. 字幕區</h2>
                <div class="input-group">
                    <label for="subtitle-file-input">上傳字幕檔 (.srt / .vtt)</label>
                    <input type="file" id="subtitle-file-input" accept=".srt,.vtt">
                </div>
                <div id="subtitle-info"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="section" id="settings-section">
                <h2>3. 擷取設定</h2>
                <div class="input-group">
                    <label for="start-time-input">起始時間 (hh:mm:ss)</label>
                    <input type="text" id="start-time-input" value="00:00:01">
                </div>
                <div class="input-group">
                    <label for="interval-input">擷取間隔 (秒)</label>
                    <input type="number" id="interval-input" value="30" min="1">
                </div>
                 <div class="input-group">
                    <label>模式切換</label>
                    <div id="mode-switcher">
                        <input type="radio" id="mode1" name="mode" value="1" checked>
                        <label for="mode1">模式 1：疊加字幕</label>
                        <br>
                        <input type="radio" id="mode2" name="mode" value="2">
                        <label for="mode2">模式 2：分欄字幕</label>
                        <br>
                        <input type="radio" id="mode3" name="mode" value="3">
                        <label for="mode3">✨ 模式 3：文章卡片樣式 ✨</label>
                    </div>
                </div>
                
                <!-- 模式3專屬設定 -->
                <div id="mode3-settings" style="display:none;">
                    <div class="input-group">
                        <label for="card-title-input">🏷️ 卡片標題</label>
                        <input type="text" id="card-title-input" placeholder="輸入自定義標題..." value="ChatGPT 搜尋提示">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            💡 提示：留空則不顯示標題和橫線
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="theme-color-input">主題色彩</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="color" id="theme-color-input" value="#1877f2">
                            <span id="color-preview" style="font-size: 12px; color: #666;">#1877f2</span>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="title-font-size-input">標題字體大小: <span id="title-font-size-display">22px</span></label>
                        <input type="range" id="title-font-size-input" min="18" max="28" value="22">
                    </div>
                    <div class="input-group">
                        <label for="content-font-size-input">內容字體大小: <span id="content-font-size-display">16px</span></label>
                        <input type="range" id="content-font-size-input" min="14" max="20" value="16">
                    </div>
                </div>
                <button id="capture-btn">擷取截圖</button>
            </div>

            <div class="section" id="output-section">
                <h2>4. 輸出區</h2>
                <button id="download-all-zip-btn" style="display:none; margin-bottom: 15px; padding: 10px 20px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">📦 一鍵打包全部圖片 (ZIP)</button>
                <div id="batch-progress"></div>
                <div id="output-preview"></div>
                <button id="download-btn" style="display:none;">下載選中圖片</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let subtitles = [];
        let videoFileName = '';
        let subtitleFileName = '';
        let imageCounter = 0; // 全局圖片計數器，按生成順序編號

        const videoFileInput = document.getElementById('video-file-input');
        const videoPlayer = document.getElementById('video-player');
        const subtitleFileInput = document.getElementById('subtitle-file-input');
        const subtitleInfo = document.getElementById('subtitle-info');
        const startTimeInput = document.getElementById('start-time-input');
        const intervalInput = document.getElementById('interval-input');
        const mode1Radio = document.getElementById('mode1');
        const mode2Radio = document.getElementById('mode2');
        const mode3Radio = document.getElementById('mode3');
        const mode3Settings = document.getElementById('mode3-settings');
        const cardTitleInput = document.getElementById('card-title-input');
        const themeColorInput = document.getElementById('theme-color-input');
        const titleFontSizeInput = document.getElementById('title-font-size-input');
        const contentFontSizeInput = document.getElementById('content-font-size-input');
        const titleFontSizeDisplay = document.getElementById('title-font-size-display');
        const contentFontSizeDisplay = document.getElementById('content-font-size-display');
        const colorPreview = document.getElementById('color-preview');
        const captureBtn = document.getElementById('capture-btn');
        const batchProgress = document.getElementById('batch-progress');
        const outputPreview = document.getElementById('output-preview');
        const downloadBtn = document.getElementById('download-btn');
        const downloadAllZipBtn = document.getElementById('download-all-zip-btn');

        videoFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                videoFileName = file.name.split('.').slice(0, -1).join('.') || 'video';
                videoPlayer.src = URL.createObjectURL(file);
                console.log('影片已載入:', videoFileName);
            }
        });

        subtitleFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                // 保存字幕檔名（去除副檔名）
                subtitleFileName = file.name.split('.').slice(0, -1).join('.') || 'subtitles';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    console.log('字幕檔內容前100字:', content.substring(0, 100));
                    subtitles = parseSrt(content);
                    console.log('解析後字幕:', subtitles.slice(0, 3));
                    subtitleInfo.textContent = `已載入: ${file.name} (${subtitles.length} 條字幕)`;
                };
                reader.readAsText(file);
            }
        });

        // 模式切換事件監聽器
        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                mode3Settings.style.display = mode3Radio.checked ? 'block' : 'none';
            });
        });

        // 字體大小滑桿事件監聽器
        titleFontSizeInput.addEventListener('input', function() {
            titleFontSizeDisplay.textContent = this.value + 'px';
        });

        contentFontSizeInput.addEventListener('input', function() {
            contentFontSizeDisplay.textContent = this.value + 'px';
        });

        // 顏色選擇器事件監聽器
        themeColorInput.addEventListener('input', function() {
            colorPreview.textContent = this.value.toUpperCase();
            colorPreview.style.color = this.value;
        });

        captureBtn.addEventListener('click', async function() {
            console.log('開始擷取，影片狀態:', videoPlayer.readyState, '字幕數量:', subtitles.length);
            
            if (!videoPlayer.src || videoPlayer.readyState < 2 || subtitles.length === 0) {
                alert('請先載入影片與字幕檔，並等待影片載入完成');
                return;
            }

            captureBtn.disabled = true;
            captureBtn.textContent = '⏳ 擷取中...';
            outputPreview.innerHTML = '';
            
            // 重置圖片編號計數器
            imageCounter = 0;
            
            downloadBtn.style.display = 'none';
            downloadAllZipBtn.style.display = 'none';

            const startTime = timeToSeconds(startTimeInput.value);
            const interval = parseFloat(intervalInput.value);
            const videoDuration = Math.floor(videoPlayer.duration);
            const endTime = videoDuration; // 直接用影片總長度
            
            console.log(`影片總長度: ${videoDuration}秒, 起始時間: ${startTime}秒, 間隔: ${interval}秒`);
            console.log(`預計產生圖片數量: ${Math.ceil((endTime - startTime) / interval)}張`);

            if (isNaN(startTime) || isNaN(interval) || interval <= 0 || startTime >= endTime) {
                alert('請輸入正確的時間與間隔');
                captureBtn.disabled = false;
                captureBtn.textContent = '擷取截圖';
                return;
            }
            const images = [];
            let current = startTime;
            const totalImages = Math.ceil((endTime - startTime) / interval);
            let processedImages = 0;

            batchProgress.textContent = `開始擷取，預計產生 ${totalImages} 張圖片...`;

            while (current < endTime) {
                processedImages++;
                console.log(`處理時間點: ${current}秒 (${processedImages}/${totalImages})`);
                batchProgress.textContent = `擷取中... (${processedImages}/${totalImages})`;
                
                // 找出這個30秒區間內的所有字幕
                const nextTime = Math.min(current + interval, endTime);
                const intervalSubs = subtitles.filter(sub => 
                    // 字幕與時間區間有重疊
                    sub.start < nextTime && sub.end > current
                );
                const mergedText = intervalSubs.map(sub => sub.text).join('\n');
                
                console.log(`時間區間 ${current}秒 - ${nextTime}秒 找到 ${intervalSubs.length} 條字幕:`, mergedText || '無字幕');

                const canvas = await captureSingleFrame(current);

                // 模式1: 直接在 canvas 上繪製字幕
                if (mode1Radio.checked && mergedText) {
                    renderSubtitleOnCanvas(canvas, mergedText);
                }

                images.push({canvas, time: current, text: mergedText, intervalStart: current, intervalEnd: nextTime});
                current += interval;
            }

            // 顯示結果
            images.forEach(({canvas, time, text, intervalStart, intervalEnd}) => {
                createThumbnail(canvas, time, text, intervalStart, intervalEnd);
            });

            batchProgress.textContent = `✅ 擷取完成，共 ${images.length} 張圖片。`;
            downloadBtn.style.display = 'block';
            downloadAllZipBtn.style.display = 'block';
            captureBtn.disabled = false;
            captureBtn.textContent = '擷取截圖';
        });

        function captureSingleFrame(time) {
            return new Promise((resolve) => {
                videoPlayer.onseeked = function() {
                    videoPlayer.onseeked = null;
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0);
                    resolve(canvas);
                };
                videoPlayer.currentTime = time;
            });
        }

        function wrapText(text, maxCharsPerLine) {
            // 將所有字幕合併成一段文字，移除原本的分行
            const fullText = text.replace(/\n/g, '').trim();
            const lines = [];
            
            for (let i = 0; i < fullText.length; i += maxCharsPerLine) {
                let line = fullText.substr(i, maxCharsPerLine);
                
                // 如果這行在句號或問號後面，嘗試在那裡斷行
                if (i + maxCharsPerLine < fullText.length) {
                    const lastPunctuation = Math.max(
                        line.lastIndexOf('。'),
                        line.lastIndexOf('？'),
                        line.lastIndexOf('！'),
                        line.lastIndexOf('，')
                    );
                    
                    if (lastPunctuation > maxCharsPerLine * 0.6) {
                        line = fullText.substr(i, lastPunctuation + 1);
                        i = i + lastPunctuation + 1 - maxCharsPerLine;
                    }
                }
                
                lines.push(line);
            }
            
            return lines;
        }

        function formatTextForMode2(text, maxCharsPerLine) {
            // 為模式2格式化文字，確保不超出寬度
            const fullText = text.replace(/\n/g, '').trim();
            const lines = [];
            
            for (let i = 0; i < fullText.length; i += maxCharsPerLine) {
                let line = fullText.substr(i, maxCharsPerLine);
                
                // 優先在標點符號處斷行
                if (i + maxCharsPerLine < fullText.length) {
                    const lastPunctuation = Math.max(
                        line.lastIndexOf('。'),
                        line.lastIndexOf('？'),
                        line.lastIndexOf('！'),
                        line.lastIndexOf('，'),
                        line.lastIndexOf('、')
                    );
                    
                    if (lastPunctuation > maxCharsPerLine * 0.5) {
                        line = fullText.substr(i, lastPunctuation + 1);
                        i = i + lastPunctuation + 1 - maxCharsPerLine;
                    }
                }
                
                lines.push(line);
            }
            
            return lines.join('\n');
        }

        function renderSubtitleOnCanvas(canvas, text) {
            if (!text) return;
            console.log('原始字幕長度:', text.length);
            const ctx = canvas.getContext('2d');
            
            // 根據畫面寬度決定每行字數
            const charsPerLine = Math.floor(canvas.width / 35); // 大約每35像素一個字
            const lines = wrapText(text, charsPerLine);
            
            console.log(`重新排版: ${lines.length} 行, 每行約 ${charsPerLine} 字`);
            
            // 根據字幕行數調整字體大小
            let fontSize = Math.max(18, Math.round(canvas.width / 45));
            if (lines.length > 8) fontSize = Math.max(16, Math.round(canvas.width / 50));
            if (lines.length > 15) fontSize = Math.max(14, Math.round(canvas.width / 55));
            if (lines.length > 25) fontSize = Math.max(12, Math.round(canvas.width / 65));
            
            ctx.font = `bold ${fontSize}px "Microsoft YaHei", Arial, sans-serif`;
            ctx.textAlign = 'center';

            const lineHeight = fontSize * 1.3;
            const padding = 15;
            const totalHeight = lineHeight * lines.length + padding * 2;
            const bgY = Math.max(5, canvas.height - totalHeight - 10);

            // 繪製黑色半透明背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, bgY, canvas.width, totalHeight);

            // 繪製白色文字
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            
            lines.forEach((line, i) => {
                const y = bgY + padding + lineHeight * (i + 1);
                ctx.strokeText(line, canvas.width / 2, y);
                ctx.fillText(line, canvas.width / 2, y);
            });
            
            console.log(`字幕繪製完成: ${lines.length} 行, 字體大小: ${fontSize}px`);
        }

        function createThumbnail(canvas, time, text, intervalStart, intervalEnd) {
            const thumbContainer = document.createElement('div');
            thumbContainer.className = 'thumbnail-container';
            thumbContainer.style.position = 'relative';
            thumbContainer.style.marginBottom = '50px'; // 增加底部間距以容納序號
            thumbContainer.style.maxWidth = '800px';
            thumbContainer.style.margin = '0 auto 50px auto';
            thumbContainer.style.overflow = 'visible'; // 改為visible以顯示序號
            thumbContainer.style.borderRadius = '8px';
            thumbContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';

            // 模式3：文章卡片樣式
            if (mode3Radio.checked) {
                createCardStyleThumbnail(thumbContainer, canvas, time, text, intervalStart, intervalEnd);
                outputPreview.appendChild(thumbContainer);
                return;
            }

            const img = document.createElement('img');
            const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
            img.src = dataUrl;
            img.style.width = '100%';
            img.style.maxWidth = '800px'; // 增加圖片最大寬度
            img.style.display = 'block';
            thumbContainer.appendChild(img);

            // 增加圖片編號
            imageCounter++;

            // 儲存資料
            thumbContainer.dataset.imageData = dataUrl;
            thumbContainer.dataset.timestamp = secondsToTimeCode(time);
            thumbContainer.dataset.imageNumber = imageCounter.toString().padStart(2, '0');
            
            // 添加序號顯示
            const numberLabel = document.createElement('div');
            numberLabel.className = 'screenshot-number';
            numberLabel.textContent = imageCounter;
            thumbContainer.appendChild(numberLabel);

            // 模式2: 顯示字幕在下方
            if (!mode1Radio.checked && text) {
                const subtitleDiv = document.createElement('div');
                subtitleDiv.style.background = 'rgba(0,0,0,0.8)';
                subtitleDiv.style.color = 'white';
                subtitleDiv.style.padding = '20px';
                subtitleDiv.style.textAlign = 'left';
                subtitleDiv.style.fontSize = '20px';
                subtitleDiv.style.lineHeight = '1.6';
                subtitleDiv.style.wordWrap = 'break-word';
                subtitleDiv.style.whiteSpace = 'pre-wrap';
                subtitleDiv.style.width = '100%'; // 確保與圖片同寬
                subtitleDiv.style.maxWidth = '800px'; // 與圖片同寬
                subtitleDiv.style.boxSizing = 'border-box';
                subtitleDiv.style.fontFamily = '"Microsoft YaHei", Arial, sans-serif';
                subtitleDiv.style.margin = '0'; // 移除預設邊距
                
                // 根據實際圖片寬度計算每行字數
                const imgWidth = Math.min(800, canvas.width);
                const charsPerLine = Math.floor(imgWidth / 20); // 大約每20像素一個字 (配合20px字體)
                
                const formattedText = formatTextForMode2(text, charsPerLine);
                subtitleDiv.textContent = formattedText;
                
                thumbContainer.appendChild(subtitleDiv);
                thumbContainer.dataset.subtitleText = text;
            }

            // 點擊選擇功能
            thumbContainer.addEventListener('click', function() {
                thumbContainer.classList.toggle('selected');
                thumbContainer.style.border = thumbContainer.classList.contains('selected') ? '3px solid #2196f3' : 'none';
            });

            outputPreview.appendChild(thumbContainer);
        }

        function createCardStyleThumbnail(thumbContainer, canvas, time, text, intervalStart, intervalEnd) {
            // 設定卡片容器樣式
            thumbContainer.style.backgroundColor = '#ffffff';
            thumbContainer.style.borderRadius = '12px';
            thumbContainer.style.boxShadow = '0 6px 16px rgba(0,0,0,0.12)';
            thumbContainer.style.padding = '0';
            thumbContainer.style.width = '640px';
            thumbContainer.style.maxWidth = '90vw';

            // 1. 標題區域（只在有標題時顯示）
            let titleText = cardTitleInput.value.trim();
            
            // 創建標題區域容器（即使是空標題也創建，方便後續編輯）
            const titleSection = document.createElement('div');
            titleSection.className = 'title-section';
            titleSection.style.padding = titleText ? '24px 24px 16px 24px' : '0';
            titleSection.style.display = titleText ? 'block' : 'none';
            
            // 創建可編輯的標題輸入框
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.value = titleText;
            titleInput.placeholder = '點擊輸入標題...';
            titleInput.className = 'card-title-editor';
            titleInput.style.cssText = `
                border: none;
                background: transparent;
                outline: none;
                width: 100%;
                margin: 0 0 8px 0;
                font-size: ${titleFontSizeInput.value}px;
                font-weight: 600;
                color: #1a1a1a;
                line-height: 1.3;
                padding: 4px 0;
                font-family: "Microsoft YaHei", Arial, sans-serif;
            `;
            
            // 創建橫線
            const underline = document.createElement('div');
            underline.className = 'title-underline';
            underline.style.cssText = `
                height: 3px;
                background-color: ${themeColorInput.value};
                border-radius: 2px;
                transition: width 0.3s ease;
            `;
            
            // 初始設置橫線寬度
            function updateUnderlineWidth() {
                const tempCanvas = document.createElement('canvas');
                const ctx = tempCanvas.getContext('2d');
                ctx.font = `600 ${titleFontSizeInput.value}px "Microsoft YaHei", Arial, sans-serif`;
                const titleWidth = ctx.measureText(titleInput.value || titleInput.placeholder).width;
                underline.style.width = titleInput.value ? titleWidth + 'px' : '0px';
            }
            
            // 標題輸入框事件監聽
            titleInput.addEventListener('input', function() {
                const hasTitle = this.value.trim() !== '';
                
                if (hasTitle) {
                    // 顯示標題區域
                    titleSection.style.display = 'block';
                    titleSection.style.padding = '24px 24px 16px 24px';
                    updateUnderlineWidth();
                    // 調整圖片區域padding
                    const imageSection = thumbContainer.querySelector('.image-section');
                    if (imageSection) {
                        imageSection.style.padding = '0 24px';
                    }
                } else {
                    // 隱藏標題區域
                    titleSection.style.display = 'none';
                    titleSection.style.padding = '0';
                    underline.style.width = '0px';
                    // 調整圖片區域padding
                    const imageSection = thumbContainer.querySelector('.image-section');
                    if (imageSection) {
                        imageSection.style.padding = '24px 24px 0 24px';
                    }
                }
            });
            
            titleInput.addEventListener('focus', function() {
                this.style.backgroundColor = '#f8f9fa';
                this.style.borderRadius = '4px';
                this.style.padding = '4px 8px';
            });
            
            titleInput.addEventListener('blur', function() {
                this.style.backgroundColor = 'transparent';
                this.style.padding = '4px 0';
            });
            
            updateUnderlineWidth();
            
            titleSection.appendChild(titleInput);
            titleSection.appendChild(underline);
            thumbContainer.appendChild(titleSection);

            // 2. 圖片區域
            const imageSection = document.createElement('div');
            imageSection.className = 'image-section';
            // 如果沒有標題，圖片區域需要頂部padding
            imageSection.style.padding = titleText ? '0 24px' : '24px 24px 0 24px';
            
            const img = document.createElement('img');
            const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
            img.src = dataUrl;
            img.style.width = '100%';
            img.style.borderRadius = '8px';
            img.style.display = 'block';
            
            imageSection.appendChild(img);
            thumbContainer.appendChild(imageSection);

            // 3. 字幕區域
            if (text && text.trim()) {
                const subtitleSection = document.createElement('div');
                subtitleSection.style.padding = '20px 24px 24px 24px';
                
                // 將30秒內的字幕整合成段落
                const formattedText = formatSubtitleForCard(text);
                
                const subtitleContent = document.createElement('div');
                subtitleContent.contentEditable = true;
                subtitleContent.style.fontSize = contentFontSizeInput.value + 'px';
                subtitleContent.style.lineHeight = '1.6';
                subtitleContent.style.color = '#444444';
                subtitleContent.style.fontFamily = '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", Arial, sans-serif';
                subtitleContent.style.whiteSpace = 'pre-wrap';
                subtitleContent.style.wordBreak = 'break-word';
                subtitleContent.style.overflowWrap = 'break-word';
                subtitleContent.style.border = '1px solid transparent';
                subtitleContent.style.borderRadius = '4px';
                subtitleContent.style.padding = '8px';
                subtitleContent.style.transition = 'border-color 0.2s';
                subtitleContent.style.cursor = 'text';
                subtitleContent.innerHTML = formattedText;
                
                // 編輯狀態樣式
                subtitleContent.addEventListener('focus', function() {
                    this.style.borderColor = themeColorInput.value;
                    this.style.backgroundColor = '#f9f9f9';
                    this.style.outline = 'none';
                });
                
                subtitleContent.addEventListener('blur', function() {
                    this.style.borderColor = 'transparent';
                    this.style.backgroundColor = 'transparent';
                    // 更新存儲的字幕文字
                    thumbContainer.dataset.subtitleText = this.innerText;
                });
                
                // 顯示編輯提示
                subtitleContent.title = '點擊此處編輯字幕內容';
                
                subtitleSection.appendChild(subtitleContent);
                
                // 添加更新按鈕
                const updateButton = document.createElement('button');
                updateButton.textContent = '🔄 更新卡片';
                updateButton.style.marginTop = '12px';
                updateButton.style.padding = '8px 16px';
                updateButton.style.fontSize = '14px';
                updateButton.style.backgroundColor = themeColorInput.value;
                updateButton.style.color = 'white';
                updateButton.style.border = 'none';
                updateButton.style.borderRadius = '6px';
                updateButton.style.cursor = 'pointer';
                updateButton.style.transition = 'opacity 0.2s';
                
                updateButton.addEventListener('click', function() {
                    // 更新卡片圖像數據
                    const editedText = subtitleContent.innerText;
                    thumbContainer.dataset.subtitleText = editedText;
                    
                    // 重新生成卡片圖像
                    createCardImage(thumbContainer).then(blob => {
                        const reader = new FileReader();
                        reader.onload = function() {
                            thumbContainer.dataset.imageData = reader.result;
                            // 更新預覽圖片
                            const img = thumbContainer.querySelector('img');
                            if (img) {
                                img.src = reader.result;
                            }
                        };
                        reader.readAsDataURL(blob);
                    });
                    
                    updateButton.textContent = '✅ 已更新';
                    setTimeout(() => {
                        updateButton.textContent = '🔄 更新卡片';
                    }, 2000);
                });
                
                updateButton.addEventListener('mouseenter', function() {
                    this.style.opacity = '0.8';
                });
                
                updateButton.addEventListener('mouseleave', function() {
                    this.style.opacity = '1';
                });
                
                subtitleSection.appendChild(updateButton);
                thumbContainer.appendChild(subtitleSection);
            }

            // 增加圖片編號（模式3）
            imageCounter++;

            // 儲存資料
            thumbContainer.dataset.imageData = dataUrl;
            thumbContainer.dataset.timestamp = secondsToTimeCode(time);
            thumbContainer.dataset.subtitleText = text;
            thumbContainer.dataset.cardTitle = titleText || '';
            thumbContainer.dataset.mode = '3';
            thumbContainer.dataset.imageNumber = imageCounter.toString().padStart(2, '0');
            
            // 添加序號顯示（模式3）
            const numberLabel = document.createElement('div');
            numberLabel.className = 'screenshot-number';
            numberLabel.textContent = imageCounter;
            thumbContainer.appendChild(numberLabel);

            // 點擊選擇功能
            thumbContainer.addEventListener('click', function() {
                thumbContainer.classList.toggle('selected');
                thumbContainer.style.border = thumbContainer.classList.contains('selected') ? '3px solid ' + themeColorInput.value : 'none';
            });
        }

        function formatSubtitleForCard(text) {
            if (!text) return '';
            
            // 移除多餘的換行符號，將文字整合
            const cleanText = text.replace(/\n+/g, '').trim();
            
            // 根據標點符號分段
            const sentences = cleanText.split(/([。！？])/).filter(s => s.trim());
            let paragraphs = [];
            let currentParagraph = '';
            
            for (let i = 0; i < sentences.length; i += 2) {
                const sentence = sentences[i] + (sentences[i + 1] || '');
                
                if (currentParagraph.length + sentence.length > 120) {
                    if (currentParagraph) {
                        paragraphs.push(currentParagraph.trim());
                    }
                    currentParagraph = sentence;
                } else {
                    currentParagraph += sentence;
                }
            }
            
            if (currentParagraph.trim()) {
                paragraphs.push(currentParagraph.trim());
            }
            
            return paragraphs.join('\n\n');
        }

        function wrapTextForCanvas(ctx, text, maxWidth) {
            const words = text.split('');
            const lines = [];
            let currentLine = '';
            
            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i];
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            return lines;
        }

        function createCardImage(thumbContainer) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // 設定畫布尺寸
                const cardWidth = 640;
                const padding = 24;
                const titleFontSize = parseInt(titleFontSizeInput.value);
                const contentFontSize = parseInt(contentFontSizeInput.value);
                
                // 獲取資料
                const originalImg = thumbContainer.querySelector('img');
                const titleText = thumbContainer.dataset.cardTitle || '';
                const subtitleText = thumbContainer.dataset.subtitleText || '';
                const themeColor = themeColorInput.value;
                
                const img = new Image();
                img.onload = function() {
                    // 計算各區域高度
                    const titleHeight = titleText ? titleFontSize + 16 : 0; // 只有有標題時才計算
                    const underlineHeight = titleText ? 12 : 0; // 只有有標題時才計算底線
                    const imageHeight = (img.height / img.width) * (cardWidth - padding * 2);
                    
                    // 計算文字區域高度 - 考慮自動換行
                    const formattedText = formatSubtitleForCard(subtitleText);
                    const textLines = formattedText.split('\n');
                    const lineHeight = contentFontSize * 1.6;
                    
                    // 設置字體以測量文字
                    ctx.font = `${contentFontSize}px "Microsoft YaHei", Arial, sans-serif`;
                    const maxWidth = cardWidth - padding * 2;
                    
                    let totalTextLines = 0;
                    textLines.forEach(paragraph => {
                        if (paragraph.trim()) {
                            const wrappedLines = wrapTextForCanvas(ctx, paragraph.trim(), maxWidth);
                            totalTextLines += wrappedLines.length;
                        }
                    });
                    
                    // 加上段落間距
                    const paragraphSpacing = (textLines.filter(p => p.trim()).length - 1) * lineHeight * 0.5;
                    const textHeight = totalTextLines > 0 ? totalTextLines * lineHeight + paragraphSpacing + padding : 0;
                    
                    // 計算總高度，如果沒有標題則不包含標題和底線的空間
                    const totalHeight = padding + titleHeight + underlineHeight + (titleText ? padding : 0) + imageHeight + padding + textHeight + padding;
                    
                    canvas.width = cardWidth;
                    canvas.height = totalHeight;
                    
                    // 背景
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, cardWidth, totalHeight);
                    
                    let currentY = padding;
                    
                    // 1. 繪製標題（只在有標題時）
                    if (titleText) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.font = `600 ${titleFontSize}px "Microsoft YaHei", Arial, sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.fillText(titleText, padding, currentY + titleFontSize);
                        
                        // 測量標題寬度
                        const titleWidth = ctx.measureText(titleText).width;
                        currentY += titleHeight;
                        
                        // 2. 繪製底線 - 與標題同寬
                        ctx.fillStyle = themeColor;
                        ctx.fillRect(padding, currentY, titleWidth, 3);
                        currentY += underlineHeight + padding;
                    }
                    
                    // 3. 繪製圖片
                    const imageWidth = cardWidth - padding * 2;
                    ctx.drawImage(img, padding, currentY, imageWidth, imageHeight);
                    currentY += imageHeight + padding;
                    
                    // 4. 繪製字幕 - 支援自動換行
                    if (textLines.length > 0) {
                        ctx.fillStyle = '#444444';
                        ctx.font = `${contentFontSize}px "Microsoft YaHei", Arial, sans-serif`;
                        ctx.textAlign = 'left';
                        
                        const maxWidth = cardWidth - padding * 2;
                        let currentTextY = currentY;
                        
                        textLines.forEach((paragraph, paragraphIndex) => {
                            if (paragraph.trim()) {
                                // 將每個段落進行自動換行處理
                                const wrappedLines = wrapTextForCanvas(ctx, paragraph.trim(), maxWidth);
                                
                                wrappedLines.forEach((line, lineIndex) => {
                                    ctx.fillText(line, padding, currentTextY + lineHeight);
                                    currentTextY += lineHeight;
                                });
                                
                                // 段落間加空行
                                if (paragraphIndex < textLines.length - 1 && textLines[paragraphIndex + 1].trim()) {
                                    currentTextY += lineHeight * 0.5;
                                }
                            }
                        });
                    }
                    
                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                };
                img.src = thumbContainer.dataset.imageData;
            });
        }

        downloadAllZipBtn.addEventListener('click', function() {
            const allThumbnails = outputPreview.querySelectorAll('.thumbnail-container');
            if (!allThumbnails.length) {
                alert('沒有圖片可以打包');
                return;
            }

            const zip = new JSZip();
            let processed = 0;
            const totalCount = allThumbnails.length;

            // 顯示打包進度
            downloadAllZipBtn.textContent = '⏳ 正在打包...';
            downloadAllZipBtn.disabled = true;

            allThumbnails.forEach((thumb, idx) => {
                const imageNumber = thumb.dataset.imageNumber;
                const fileName = generateFileName(imageNumber);
                const subtitleText = thumb.dataset.subtitleText;
                
                // 檢查模式並處理
                const mode = thumb.dataset.mode || '1';
                
                if (mode === '3') {
                    // 模式3：文章卡片樣式 - 需要重新創建整個卡片
                    createCardImage(thumb).then(blob => {
                        const reader = new FileReader();
                        reader.onload = function() {
                            const base64data = reader.result.split(',')[1];
                            zip.file(fileName, base64data, {base64: true});
                            processed++;
                            
                            if (processed === totalCount) {
                                zip.generateAsync({type: 'blob'}).then(function(content) {
                                    const link = document.createElement('a');
                                    link.href = URL.createObjectURL(content);
                                    link.download = `${subtitleFileName || videoFileName || 'images'}_全部圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                                    link.click();
                                    
                                    downloadAllZipBtn.textContent = '📦 一鍵打包全部圖片 (ZIP)';
                                    downloadAllZipBtn.disabled = false;
                                });
                            }
                        };
                        reader.readAsDataURL(blob);
                    });
                } else if (mode === '2' && subtitleText) {
                    // 模式2: 需要合成圖片和字幕
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // 計算字幕區域高度
                        const fontSize = 20;
                        const lineHeight = fontSize * 1.6;
                        const padding = 20;
                        const charsPerLine = Math.floor(img.width / 20);
                        const formattedText = formatTextForMode2(subtitleText, charsPerLine);
                        const lines = formattedText.split('\n');
                        const subtitleHeight = lines.length * lineHeight + padding * 2;
                        
                        canvas.width = img.width;
                        canvas.height = img.height + subtitleHeight;
                        
                        // 繪製圖片
                        ctx.drawImage(img, 0, 0);
                        
                        // 繪製字幕背景
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, img.height, img.width, subtitleHeight);
                        
                        // 繪製字幕文字
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        
                        lines.forEach((line, lineIdx) => {
                            const y = img.height + padding + (lineIdx + 1) * lineHeight;
                            ctx.fillText(line.trim(), img.width / 2, y);
                        });
                        
                        canvas.toBlob(function(blob) {
                            const reader = new FileReader();
                            reader.onload = function() {
                                const base64data = reader.result.split(',')[1];
                                zip.file(fileName, base64data, {base64: true});
                                processed++;
                                
                                if (processed === totalCount) {
                                    zip.generateAsync({type: 'blob'}).then(function(content) {
                                        const link = document.createElement('a');
                                        link.href = URL.createObjectURL(content);
                                        link.download = `${subtitleFileName || videoFileName || 'images'}_全部圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                                        link.click();
                                        
                                        downloadAllZipBtn.textContent = '📦 一鍵打包全部圖片 (ZIP)';
                                        downloadAllZipBtn.disabled = false;
                                    });
                                }
                            };
                            reader.readAsDataURL(blob);
                        }, 'image/jpeg', 0.9);
                    };
                    img.src = thumb.querySelector('img').src;
                } else {
                    // 模式1或無字幕: 直接使用原圖
                    const imgSrc = thumb.querySelector('img').src;
                    const base64data = imgSrc.split(',')[1];
                    zip.file(fileName, base64data, {base64: true});
                    processed++;
                    
                    if (processed === totalCount) {
                        zip.generateAsync({type: 'blob'}).then(function(content) {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = `${subtitleFileName || videoFileName || 'images'}_全部圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                            link.click();
                            
                            downloadAllZipBtn.textContent = '📦 一鍵打包全部圖片 (ZIP)';
                            downloadAllZipBtn.disabled = false;
                        });
                    }
                }
            });
        });

        // 生成檔名的函數
        function generateFileName(imageNumber) {
            const baseName = subtitleFileName || videoFileName || 'image';
            return `${baseName}_${imageNumber}.jpg`;
        }

        downloadBtn.addEventListener('click', function() {
            const selected = outputPreview.querySelectorAll('.thumbnail-container.selected');
            if (!selected.length) {
                alert('請先點擊選擇要下載的圖片');
                return;
            }

            const zip = new JSZip();
            let processed = 0;

            selected.forEach((thumb, idx) => {
                const imageNumber = thumb.dataset.imageNumber;
                const fileName = generateFileName(imageNumber);
                const subtitleText = thumb.dataset.subtitleText;
                
                // 檢查模式並處理
                const mode = thumb.dataset.mode || (mode1Radio.checked ? '1' : '2');
                
                if (mode === '3') {
                    // 模式3：文章卡片樣式
                    createCardImage(thumb).then(blob => {
                        zip.file(fileName, blob);
                        processed++;
                        if (processed === selected.length) {
                            zip.generateAsync({type: 'blob'}).then(function(content) {
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(content);
                                link.download = `${subtitleFileName || videoFileName || 'images'}_選中圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                                link.click();
                            });
                        }
                    });
                } else if (mode === '2' && subtitleText) {
                    // 模式2: 需要合成圖片和字幕
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // 計算字幕區域高度
                        const fontSize = 20;
                        const lineHeight = fontSize * 1.6;
                        const padding = 20;
                        const charsPerLine = Math.floor(img.width / 20); // 配合20px字體
                        const formattedText = formatTextForMode2(subtitleText, charsPerLine);
                        const lines = formattedText.split('\n');
                        const subtitleHeight = lines.length * lineHeight + padding * 2;
                        
                        // 設定 canvas 尺寸 (圖片 + 字幕)
                        canvas.width = img.width;
                        canvas.height = img.height + subtitleHeight;
                        
                        // 繪製圖片
                        ctx.drawImage(img, 0, 0);
                        
                        // 繪製字幕背景
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, img.height, canvas.width, subtitleHeight);
                        
                        // 繪製字幕文字
                        ctx.fillStyle = 'white';
                        ctx.font = `${fontSize}px "Microsoft YaHei", Arial, sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        
                        lines.forEach((line, i) => {
                            const y = img.height + padding + i * lineHeight;
                            ctx.fillText(line, padding, y);
                        });
                        
                        canvas.toBlob(function(blob) {
                            zip.file(fileName, blob);
                            processed++;
                            if (processed === selected.length) {
                                zip.generateAsync({type: 'blob'}).then(function(content) {
                                    const link = document.createElement('a');
                                    link.href = URL.createObjectURL(content);
                                    link.download = `${subtitleFileName || videoFileName || 'images'}_選中圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                                    link.click();
                                });
                            }
                        }, 'image/jpeg', 0.92);
                    };
                    img.src = thumb.dataset.imageData;
                } else {
                    // 模式1: 直接使用原始圖片 (已包含字幕)
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob(function(blob) {
                            zip.file(fileName, blob);
                            processed++;
                            if (processed === selected.length) {
                                zip.generateAsync({type: 'blob'}).then(function(content) {
                                    const link = document.createElement('a');
                                    link.href = URL.createObjectURL(content);
                                    link.download = `${subtitleFileName || videoFileName || 'images'}_選中圖片_${new Date().toISOString().slice(0, 10)}.zip`;
                                    link.click();
                                });
                            }
                        }, 'image/jpeg', 0.92);
                    };
                    img.src = thumb.dataset.imageData;
                }
            });
        });

        function parseSrt(data) {
            console.log('原始字幕資料長度:', data.length);
            return data.trim().split('\n\n').map(block => {
                const lines = block.split('\n');
                if (lines.length < 3) return null;
                const time = lines[1].split(' --> ');
                return {
                    start: timeToSeconds(time[0].replace(',', '.')),
                    end: timeToSeconds(time[1].replace(',', '.')),
                    text: lines.slice(2).join('\n')
                };
            }).filter(Boolean);
        }

        function timeToSeconds(timeString) {
            const parts = timeString.split(/[:,.]/);
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]) + (parseInt(parts[3] || 0) / 1000);
        }

        function secondsToTimeCode(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}-${m}-${s}`;
        }

        console.log('字幕截圖工具載入完成');
    </script>
</body>
</html>
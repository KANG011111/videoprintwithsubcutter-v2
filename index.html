<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰ç«¯å­—å¹•æˆªåœ–å·¥å…·</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>å‰ç«¯å­—å¹•æˆªåœ–å·¥å…·</h1>

    <div class="main-container">
        <div class="left-panel">
            <div class="section" id="video-section">
                <h2>1. å½±ç‰‡å€</h2>
                <div class="input-group">
                    <label for="video-file-input">ä¸Šå‚³å½±ç‰‡æª” (MP4/WebM)</label>
                    <input type="file" id="video-file-input" accept="video/mp4,video/webm">
                </div>
                <video id="video-player" controls crossorigin="anonymous"></video>
            </div>

            <div class="section" id="subtitle-section">
                <h2>2. å­—å¹•å€</h2>
                <div class="input-group">
                    <label for="subtitle-file-input">ä¸Šå‚³å­—å¹•æª” (.srt / .vtt)</label>
                    <input type="file" id="subtitle-file-input" accept=".srt,.vtt">
                </div>
                <div id="subtitle-info"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="section" id="settings-section">
                <h2>3. æ“·å–è¨­å®š</h2>
                <div class="input-group">
                    <label for="start-time-input">èµ·å§‹æ™‚é–“ (hh:mm:ss)</label>
                    <input type="text" id="start-time-input" value="00:00:01">
                </div>
                <div class="input-group">
                    <label for="interval-input">æ“·å–é–“éš” (ç§’)</label>
                    <input type="number" id="interval-input" value="30" min="1">
                </div>
                 <div class="input-group">
                    <label>æ¨¡å¼åˆ‡æ›</label>
                    <div id="mode-switcher">
                        <input type="radio" id="mode1" name="mode" value="1" checked>
                        <label for="mode1">æ¨¡å¼ 1ï¼šç–ŠåŠ å­—å¹•</label>
                        <br>
                        <input type="radio" id="mode2" name="mode" value="2">
                        <label for="mode2">æ¨¡å¼ 2ï¼šåˆ†æ¬„å­—å¹•</label>
                    </div>
                </div>
                <button id="capture-btn">æ“·å–æˆªåœ–</button>
            </div>

            <div class="section" id="output-section">
                <h2>4. è¼¸å‡ºå€</h2>
                <button id="download-all-zip-btn" style="display:none; margin-bottom: 15px; padding: 10px 20px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">ğŸ“¦ ä¸€éµæ‰“åŒ…å…¨éƒ¨åœ–ç‰‡ (ZIP)</button>
                <div id="batch-progress"></div>
                <div id="output-preview"></div>
                <button id="download-btn" style="display:none;">ä¸‹è¼‰é¸ä¸­åœ–ç‰‡</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let subtitles = [];
        let videoFileName = '';

        const videoFileInput = document.getElementById('video-file-input');
        const videoPlayer = document.getElementById('video-player');
        const subtitleFileInput = document.getElementById('subtitle-file-input');
        const subtitleInfo = document.getElementById('subtitle-info');
        const startTimeInput = document.getElementById('start-time-input');
        const intervalInput = document.getElementById('interval-input');
        const mode1Radio = document.getElementById('mode1');
        const captureBtn = document.getElementById('capture-btn');
        const batchProgress = document.getElementById('batch-progress');
        const outputPreview = document.getElementById('output-preview');
        const downloadBtn = document.getElementById('download-btn');
        const downloadAllZipBtn = document.getElementById('download-all-zip-btn');

        videoFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                videoFileName = file.name.split('.').slice(0, -1).join('.') || 'video';
                videoPlayer.src = URL.createObjectURL(file);
                console.log('å½±ç‰‡å·²è¼‰å…¥:', videoFileName);
            }
        });

        subtitleFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    console.log('å­—å¹•æª”å…§å®¹å‰100å­—:', content.substring(0, 100));
                    subtitles = parseSrt(content);
                    console.log('è§£æå¾Œå­—å¹•:', subtitles.slice(0, 3));
                    subtitleInfo.textContent = `å·²è¼‰å…¥: ${file.name} (${subtitles.length} æ¢å­—å¹•)`;
                };
                reader.readAsText(file);
            }
        });

        captureBtn.addEventListener('click', async function() {
            console.log('é–‹å§‹æ“·å–ï¼Œå½±ç‰‡ç‹€æ…‹:', videoPlayer.readyState, 'å­—å¹•æ•¸é‡:', subtitles.length);
            
            if (!videoPlayer.src || videoPlayer.readyState < 2 || subtitles.length === 0) {
                alert('è«‹å…ˆè¼‰å…¥å½±ç‰‡èˆ‡å­—å¹•æª”ï¼Œä¸¦ç­‰å¾…å½±ç‰‡è¼‰å…¥å®Œæˆ');
                return;
            }

            captureBtn.disabled = true;
            outputPreview.innerHTML = '';
            downloadBtn.style.display = 'none';
            downloadAllZipBtn.style.display = 'none';

            const startTime = timeToSeconds(startTimeInput.value);
            const interval = parseFloat(intervalInput.value);
            const videoDuration = Math.floor(videoPlayer.duration);
            const endTime = videoDuration; // ç›´æ¥ç”¨å½±ç‰‡ç¸½é•·åº¦
            
            console.log(`å½±ç‰‡ç¸½é•·åº¦: ${videoDuration}ç§’, èµ·å§‹æ™‚é–“: ${startTime}ç§’, é–“éš”: ${interval}ç§’`);
            console.log(`é è¨ˆç”¢ç”Ÿåœ–ç‰‡æ•¸é‡: ${Math.ceil((endTime - startTime) / interval)}å¼µ`);

            if (isNaN(startTime) || isNaN(interval) || interval <= 0 || startTime >= endTime) {
                alert('è«‹è¼¸å…¥æ­£ç¢ºçš„æ™‚é–“èˆ‡é–“éš”');
                captureBtn.disabled = false;
                return;
            }
            const images = [];
            let current = startTime;
            const totalImages = Math.ceil((endTime - startTime) / interval);
            let processedImages = 0;

            batchProgress.textContent = `é–‹å§‹æ“·å–ï¼Œé è¨ˆç”¢ç”Ÿ ${totalImages} å¼µåœ–ç‰‡...`;

            while (current < endTime) {
                processedImages++;
                console.log(`è™•ç†æ™‚é–“é»: ${current}ç§’ (${processedImages}/${totalImages})`);
                batchProgress.textContent = `æ“·å–ä¸­... (${processedImages}/${totalImages})`;
                
                // æ‰¾å‡ºé€™å€‹30ç§’å€é–“å…§çš„æ‰€æœ‰å­—å¹•
                const nextTime = Math.min(current + interval, endTime);
                const intervalSubs = subtitles.filter(sub => 
                    // å­—å¹•èˆ‡æ™‚é–“å€é–“æœ‰é‡ç–Š
                    sub.start < nextTime && sub.end > current
                );
                const mergedText = intervalSubs.map(sub => sub.text).join('\n');
                
                console.log(`æ™‚é–“å€é–“ ${current}ç§’ - ${nextTime}ç§’ æ‰¾åˆ° ${intervalSubs.length} æ¢å­—å¹•:`, mergedText || 'ç„¡å­—å¹•');

                const canvas = await captureSingleFrame(current);

                // æ¨¡å¼1: ç›´æ¥åœ¨ canvas ä¸Šç¹ªè£½å­—å¹•
                if (mode1Radio.checked && mergedText) {
                    renderSubtitleOnCanvas(canvas, mergedText);
                }

                images.push({canvas, time: current, text: mergedText});
                current += interval;
            }

            // é¡¯ç¤ºçµæœ
            images.forEach(({canvas, time, text}) => {
                createThumbnail(canvas, time, text);
            });

            batchProgress.textContent = `æ“·å–å®Œæˆï¼Œå…± ${images.length} å¼µåœ–ç‰‡ã€‚`;
            downloadBtn.style.display = 'block';
            downloadAllZipBtn.style.display = 'block';
            captureBtn.disabled = false;
        });

        function captureSingleFrame(time) {
            return new Promise((resolve) => {
                videoPlayer.onseeked = function() {
                    videoPlayer.onseeked = null;
                    const canvas = document.createElement('canvas');
                    canvas.width = videoPlayer.videoWidth;
                    canvas.height = videoPlayer.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(videoPlayer, 0, 0);
                    resolve(canvas);
                };
                videoPlayer.currentTime = time;
            });
        }

        function wrapText(text, maxCharsPerLine) {
            // å°‡æ‰€æœ‰å­—å¹•åˆä½µæˆä¸€æ®µæ–‡å­—ï¼Œç§»é™¤åŸæœ¬çš„åˆ†è¡Œ
            const fullText = text.replace(/\n/g, '').trim();
            const lines = [];
            
            for (let i = 0; i < fullText.length; i += maxCharsPerLine) {
                let line = fullText.substr(i, maxCharsPerLine);
                
                // å¦‚æœé€™è¡Œåœ¨å¥è™Ÿæˆ–å•è™Ÿå¾Œé¢ï¼Œå˜—è©¦åœ¨é‚£è£¡æ–·è¡Œ
                if (i + maxCharsPerLine < fullText.length) {
                    const lastPunctuation = Math.max(
                        line.lastIndexOf('ã€‚'),
                        line.lastIndexOf('ï¼Ÿ'),
                        line.lastIndexOf('ï¼'),
                        line.lastIndexOf('ï¼Œ')
                    );
                    
                    if (lastPunctuation > maxCharsPerLine * 0.6) {
                        line = fullText.substr(i, lastPunctuation + 1);
                        i = i + lastPunctuation + 1 - maxCharsPerLine;
                    }
                }
                
                lines.push(line);
            }
            
            return lines;
        }

        function formatTextForMode2(text, maxCharsPerLine) {
            // ç‚ºæ¨¡å¼2æ ¼å¼åŒ–æ–‡å­—ï¼Œç¢ºä¿ä¸è¶…å‡ºå¯¬åº¦
            const fullText = text.replace(/\n/g, '').trim();
            const lines = [];
            
            for (let i = 0; i < fullText.length; i += maxCharsPerLine) {
                let line = fullText.substr(i, maxCharsPerLine);
                
                // å„ªå…ˆåœ¨æ¨™é»ç¬¦è™Ÿè™•æ–·è¡Œ
                if (i + maxCharsPerLine < fullText.length) {
                    const lastPunctuation = Math.max(
                        line.lastIndexOf('ã€‚'),
                        line.lastIndexOf('ï¼Ÿ'),
                        line.lastIndexOf('ï¼'),
                        line.lastIndexOf('ï¼Œ'),
                        line.lastIndexOf('ã€')
                    );
                    
                    if (lastPunctuation > maxCharsPerLine * 0.5) {
                        line = fullText.substr(i, lastPunctuation + 1);
                        i = i + lastPunctuation + 1 - maxCharsPerLine;
                    }
                }
                
                lines.push(line);
            }
            
            return lines.join('\n');
        }

        function renderSubtitleOnCanvas(canvas, text) {
            if (!text) return;
            console.log('åŸå§‹å­—å¹•é•·åº¦:', text.length);
            const ctx = canvas.getContext('2d');
            
            // æ ¹æ“šç•«é¢å¯¬åº¦æ±ºå®šæ¯è¡Œå­—æ•¸
            const charsPerLine = Math.floor(canvas.width / 35); // å¤§ç´„æ¯35åƒç´ ä¸€å€‹å­—
            const lines = wrapText(text, charsPerLine);
            
            console.log(`é‡æ–°æ’ç‰ˆ: ${lines.length} è¡Œ, æ¯è¡Œç´„ ${charsPerLine} å­—`);
            
            // æ ¹æ“šå­—å¹•è¡Œæ•¸èª¿æ•´å­—é«”å¤§å°
            let fontSize = Math.max(18, Math.round(canvas.width / 45));
            if (lines.length > 8) fontSize = Math.max(16, Math.round(canvas.width / 50));
            if (lines.length > 15) fontSize = Math.max(14, Math.round(canvas.width / 55));
            if (lines.length > 25) fontSize = Math.max(12, Math.round(canvas.width / 65));
            
            ctx.font = `bold ${fontSize}px "Microsoft YaHei", Arial, sans-serif`;
            ctx.textAlign = 'center';

            const lineHeight = fontSize * 1.3;
            const padding = 15;
            const totalHeight = lineHeight * lines.length + padding * 2;
            const bgY = Math.max(5, canvas.height - totalHeight - 10);

            // ç¹ªè£½é»‘è‰²åŠé€æ˜èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, bgY, canvas.width, totalHeight);

            // ç¹ªè£½ç™½è‰²æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            
            lines.forEach((line, i) => {
                const y = bgY + padding + lineHeight * (i + 1);
                ctx.strokeText(line, canvas.width / 2, y);
                ctx.fillText(line, canvas.width / 2, y);
            });
            
            console.log(`å­—å¹•ç¹ªè£½å®Œæˆ: ${lines.length} è¡Œ, å­—é«”å¤§å°: ${fontSize}px`);
        }

        function createThumbnail(canvas, time, text) {
            const thumbContainer = document.createElement('div');
            thumbContainer.className = 'thumbnail-container';
            thumbContainer.style.position = 'relative';
            thumbContainer.style.marginBottom = '30px';
            thumbContainer.style.maxWidth = '800px'; // çµ±ä¸€æœ€å¤§å¯¬åº¦
            thumbContainer.style.margin = '0 auto 30px auto'; // å±…ä¸­é¡¯ç¤º
            thumbContainer.style.overflow = 'hidden';
            thumbContainer.style.borderRadius = '8px'; // åœ“è§’
            thumbContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)'; // é™°å½±

            const img = document.createElement('img');
            const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
            img.src = dataUrl;
            img.style.width = '100%';
            img.style.maxWidth = '800px'; // å¢åŠ åœ–ç‰‡æœ€å¤§å¯¬åº¦
            img.style.display = 'block';
            thumbContainer.appendChild(img);

            // å„²å­˜è³‡æ–™
            thumbContainer.dataset.imageData = dataUrl;
            thumbContainer.dataset.timestamp = secondsToTimeCode(time);

            // æ¨¡å¼2: é¡¯ç¤ºå­—å¹•åœ¨ä¸‹æ–¹
            if (!mode1Radio.checked && text) {
                const subtitleDiv = document.createElement('div');
                subtitleDiv.style.background = 'rgba(0,0,0,0.8)';
                subtitleDiv.style.color = 'white';
                subtitleDiv.style.padding = '20px';
                subtitleDiv.style.textAlign = 'left';
                subtitleDiv.style.fontSize = '20px';
                subtitleDiv.style.lineHeight = '1.6';
                subtitleDiv.style.wordWrap = 'break-word';
                subtitleDiv.style.whiteSpace = 'pre-wrap';
                subtitleDiv.style.width = '100%'; // ç¢ºä¿èˆ‡åœ–ç‰‡åŒå¯¬
                subtitleDiv.style.maxWidth = '800px'; // èˆ‡åœ–ç‰‡åŒå¯¬
                subtitleDiv.style.boxSizing = 'border-box';
                subtitleDiv.style.fontFamily = '"Microsoft YaHei", Arial, sans-serif';
                subtitleDiv.style.margin = '0'; // ç§»é™¤é è¨­é‚Šè·
                
                // æ ¹æ“šå¯¦éš›åœ–ç‰‡å¯¬åº¦è¨ˆç®—æ¯è¡Œå­—æ•¸
                const imgWidth = Math.min(800, canvas.width);
                const charsPerLine = Math.floor(imgWidth / 20); // å¤§ç´„æ¯20åƒç´ ä¸€å€‹å­— (é…åˆ20pxå­—é«”)
                
                const formattedText = formatTextForMode2(text, charsPerLine);
                subtitleDiv.textContent = formattedText;
                
                thumbContainer.appendChild(subtitleDiv);
                thumbContainer.dataset.subtitleText = text;
            }

            // é»æ“Šé¸æ“‡åŠŸèƒ½
            thumbContainer.addEventListener('click', function() {
                thumbContainer.classList.toggle('selected');
                thumbContainer.style.border = thumbContainer.classList.contains('selected') ? '3px solid #2196f3' : 'none';
            });

            outputPreview.appendChild(thumbContainer);
        }

        downloadAllZipBtn.addEventListener('click', function() {
            const allThumbnails = outputPreview.querySelectorAll('.thumbnail-container');
            if (!allThumbnails.length) {
                alert('æ²’æœ‰åœ–ç‰‡å¯ä»¥æ‰“åŒ…');
                return;
            }

            const zip = new JSZip();
            let processed = 0;
            const totalCount = allThumbnails.length;

            // é¡¯ç¤ºæ‰“åŒ…é€²åº¦
            downloadAllZipBtn.textContent = 'â³ æ­£åœ¨æ‰“åŒ…...';
            downloadAllZipBtn.disabled = true;

            allThumbnails.forEach((thumb, idx) => {
                const fileName = `${videoFileName}_${thumb.dataset.timestamp}_${idx + 1}.jpg`;
                const subtitleText = thumb.dataset.subtitleText;
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºæ¨¡å¼2ä¸”æœ‰å­—å¹•
                if (!mode1Radio.checked && subtitleText) {
                    // æ¨¡å¼2: éœ€è¦åˆæˆåœ–ç‰‡å’Œå­—å¹•
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // è¨ˆç®—å­—å¹•å€åŸŸé«˜åº¦
                        const fontSize = 20;
                        const lineHeight = fontSize * 1.6;
                        const padding = 20;
                        const charsPerLine = Math.floor(img.width / 20);
                        const formattedText = formatTextForMode2(subtitleText, charsPerLine);
                        const lines = formattedText.split('\n');
                        const subtitleHeight = lines.length * lineHeight + padding * 2;
                        
                        canvas.width = img.width;
                        canvas.height = img.height + subtitleHeight;
                        
                        // ç¹ªè£½åœ–ç‰‡
                        ctx.drawImage(img, 0, 0);
                        
                        // ç¹ªè£½å­—å¹•èƒŒæ™¯
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, img.height, img.width, subtitleHeight);
                        
                        // ç¹ªè£½å­—å¹•æ–‡å­—
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        
                        lines.forEach((line, lineIdx) => {
                            const y = img.height + padding + (lineIdx + 1) * lineHeight;
                            ctx.fillText(line.trim(), img.width / 2, y);
                        });
                        
                        canvas.toBlob(function(blob) {
                            const reader = new FileReader();
                            reader.onload = function() {
                                const base64data = reader.result.split(',')[1];
                                zip.file(fileName, base64data, {base64: true});
                                processed++;
                                
                                if (processed === totalCount) {
                                    zip.generateAsync({type: 'blob'}).then(function(content) {
                                        const link = document.createElement('a');
                                        link.href = URL.createObjectURL(content);
                                        link.download = `${videoFileName}_all_screenshots.zip`;
                                        link.click();
                                        
                                        downloadAllZipBtn.textContent = 'ğŸ“¦ ä¸€éµæ‰“åŒ…å…¨éƒ¨åœ–ç‰‡ (ZIP)';
                                        downloadAllZipBtn.disabled = false;
                                    });
                                }
                            };
                            reader.readAsDataURL(blob);
                        }, 'image/jpeg', 0.9);
                    };
                    img.src = thumb.querySelector('img').src;
                } else {
                    // æ¨¡å¼1æˆ–ç„¡å­—å¹•: ç›´æ¥ä½¿ç”¨åŸåœ–
                    const imgSrc = thumb.querySelector('img').src;
                    const base64data = imgSrc.split(',')[1];
                    zip.file(fileName, base64data, {base64: true});
                    processed++;
                    
                    if (processed === totalCount) {
                        zip.generateAsync({type: 'blob'}).then(function(content) {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = `${videoFileName}_all_screenshots.zip`;
                            link.click();
                            
                            downloadAllZipBtn.textContent = 'ğŸ“¦ ä¸€éµæ‰“åŒ…å…¨éƒ¨åœ–ç‰‡ (ZIP)';
                            downloadAllZipBtn.disabled = false;
                        });
                    }
                }
            });
        });

        downloadBtn.addEventListener('click', function() {
            const selected = outputPreview.querySelectorAll('.thumbnail-container.selected');
            if (!selected.length) {
                alert('è«‹å…ˆé»æ“Šé¸æ“‡è¦ä¸‹è¼‰çš„åœ–ç‰‡');
                return;
            }

            const zip = new JSZip();
            let processed = 0;

            selected.forEach((thumb, idx) => {
                const fileName = `${videoFileName}_${thumb.dataset.timestamp}_${idx + 1}.jpg`;
                const subtitleText = thumb.dataset.subtitleText;
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºæ¨¡å¼2ä¸”æœ‰å­—å¹•
                if (!mode1Radio.checked && subtitleText) {
                    // æ¨¡å¼2: éœ€è¦åˆæˆåœ–ç‰‡å’Œå­—å¹•
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // è¨ˆç®—å­—å¹•å€åŸŸé«˜åº¦
                        const fontSize = 20;
                        const lineHeight = fontSize * 1.6;
                        const padding = 20;
                        const charsPerLine = Math.floor(img.width / 20); // é…åˆ20pxå­—é«”
                        const formattedText = formatTextForMode2(subtitleText, charsPerLine);
                        const lines = formattedText.split('\n');
                        const subtitleHeight = lines.length * lineHeight + padding * 2;
                        
                        // è¨­å®š canvas å°ºå¯¸ (åœ–ç‰‡ + å­—å¹•)
                        canvas.width = img.width;
                        canvas.height = img.height + subtitleHeight;
                        
                        // ç¹ªè£½åœ–ç‰‡
                        ctx.drawImage(img, 0, 0);
                        
                        // ç¹ªè£½å­—å¹•èƒŒæ™¯
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, img.height, canvas.width, subtitleHeight);
                        
                        // ç¹ªè£½å­—å¹•æ–‡å­—
                        ctx.fillStyle = 'white';
                        ctx.font = `${fontSize}px "Microsoft YaHei", Arial, sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        
                        lines.forEach((line, i) => {
                            const y = img.height + padding + i * lineHeight;
                            ctx.fillText(line, padding, y);
                        });
                        
                        canvas.toBlob(function(blob) {
                            zip.file(fileName, blob);
                            processed++;
                            if (processed === selected.length) {
                                zip.generateAsync({type: 'blob'}).then(function(content) {
                                    const link = document.createElement('a');
                                    link.href = URL.createObjectURL(content);
                                    link.download = `${videoFileName}_images.zip`;
                                    link.click();
                                });
                            }
                        }, 'image/jpeg', 0.92);
                    };
                    img.src = thumb.dataset.imageData;
                } else {
                    // æ¨¡å¼1: ç›´æ¥ä½¿ç”¨åŸå§‹åœ–ç‰‡ (å·²åŒ…å«å­—å¹•)
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob(function(blob) {
                            zip.file(fileName, blob);
                            processed++;
                            if (processed === selected.length) {
                                zip.generateAsync({type: 'blob'}).then(function(content) {
                                    const link = document.createElement('a');
                                    link.href = URL.createObjectURL(content);
                                    link.download = `${videoFileName}_images.zip`;
                                    link.click();
                                });
                            }
                        }, 'image/jpeg', 0.92);
                    };
                    img.src = thumb.dataset.imageData;
                }
            });
        });

        function parseSrt(data) {
            console.log('åŸå§‹å­—å¹•è³‡æ–™é•·åº¦:', data.length);
            return data.trim().split('\n\n').map(block => {
                const lines = block.split('\n');
                if (lines.length < 3) return null;
                const time = lines[1].split(' --> ');
                return {
                    start: timeToSeconds(time[0].replace(',', '.')),
                    end: timeToSeconds(time[1].replace(',', '.')),
                    text: lines.slice(2).join('\n')
                };
            }).filter(Boolean);
        }

        function timeToSeconds(timeString) {
            const parts = timeString.split(/[:,.]/);
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]) + (parseInt(parts[3] || 0) / 1000);
        }

        function secondsToTimeCode(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}-${m}-${s}`;
        }

        console.log('å­—å¹•æˆªåœ–å·¥å…·è¼‰å…¥å®Œæˆ');
    </script>
</body>
</html>